<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;margin:20px}
.container{display:flex;flex-direction:column;gap:15px}
.upload-row{display:flex;gap:15px}
.reset-box{width:120px;border:2px dashed #ccc;padding:15px;text-align:center;min-height:100px;display:none;flex-direction:column;justify-content:center;position:relative;transition:all 0.3s;background:#f8f9fa;border-radius:4px;cursor:pointer}
.reset-box:hover{background:#e9ecef;border-color:#6c757d}
.reset-box h3{margin:0 0 8px;font-size:16px;color:#495057}
.upload-box{flex:1;border:2px dashed #ccc;padding:15px;text-align:center;min-height:100px;display:flex;flex-direction:column;justify-content:center;position:relative;transition:all 0.3s;cursor:pointer}
.upload-box.compact{padding:8px !important;min-height:60px !important;border-width:1px !important}
.upload-box.disabled{border-color:#e0e0e0;background:#f5f5f5;cursor:not-allowed}
.upload-box.disabled h3,.upload-box.disabled div{color:#999}
.upload-box h3{margin:0 0 8px;font-size:16px}
.upload-box.compact h3{font-size:12px;margin:0 0 3px}
.upload-box.compact div{font-size:11px}
.upload-box.active{border-color:#0052cc;background:#f0f7ff}
.upload-box.inactive{opacity:0.5;filter:grayscale(50%)}
input[type="file"]{display:none}
.btn{background:#0052cc;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;margin:3px;font-size:13px}
.btn:disabled{background:#ccc}
.btn-secondary{background:#6c757d}
.error{color:#d00;background:#fee;padding:8px;border-radius:4px;display:none}
.warning{color:#856404;background:#fff3cd;padding:10px;border-radius:4px;display:none;margin:10px 0;border-left:4px solid #ffc107;max-height:400px;overflow-y:auto}
.editor{display:none;border:1px solid #ddd;border-radius:4px;position:relative;margin-bottom:160px !important}
.editor-header{display:grid;grid-template-columns:1fr 1fr;background:#f5f5f5;padding:8px;border-bottom:1px solid #ddd;font-size:13px}
.translation-list{}
.translation-item{display:grid;grid-template-columns:1fr 1fr;padding:10px;border-bottom:1px solid #eee;gap:10px;align-items:start}
.translation-item:nth-child(even){background:#fafafa}
.source-area{position:relative}
.source-text{padding:6px;border-left:3px solid #0052cc;background:#f0f7ff;border-radius:4px;white-space:pre-wrap;word-break:break-word;transition:border-color 0.2s;font-size:13px;unicode-bidi:plaintext;text-align:start}
.source-text.changed{border-left-color:#ff9800 !important;background:#fff8e1}
.source-input{width:100%;padding:6px;border:1px solid #b3d4ff;border-radius:4px;resize:vertical;font-family:inherit;min-height:35px;box-sizing:border-box;font-size:13px;unicode-bidi:plaintext;text-align:start}
.source-input.changed{border-color:#ff9800 !important;background:#fff8e1}
.lock-btn{position:absolute;top:6px;right:6px;background:none;border:none;cursor:pointer;font-size:12px;opacity:0.5;z-index:10;padding:2px}
.lock-btn:hover{opacity:1}
.translation-input{width:100%;padding:6px;border:1px solid #ddd;border-radius:4px;resize:vertical;font-family:inherit;min-height:35px;transition:border-color 0.2s, background-color 0.2s;font-size:13px;unicode-bidi:plaintext;text-align:start}
.translation-input:focus{outline:none;border-color:#0052cc;box-shadow:0 0 0 2px rgba(0,82,204,0.1)}
.translation-input.changed{border-color:#ff9800 !important;background:#fff8e1}
.key-path{font-family:monospace;font-size:11px;color:#666;padding:4px 0 0 0;margin-top:4px;border-top:1px dashed #ddd;unicode-bidi:plaintext;text-align:start}
.array-indicator{color:#28a745;font-size:10px;margin-left:4px;background:#e8f5e9;padding:1px 4px;border-radius:8px}
.action-buttons{display:flex;gap:8px;justify-content:center;margin:15px 0;padding-top:15px;border-top:1px solid #e9ecef}
.status{text-align:center;padding:15px;color:#666}
.file-info{font-size:11px;color:#666;margin-top:5px}
.upload-box.compact .file-info{font-size:9px}
.control-buttons{display:flex;gap:8px;justify-content:center;align-items:center;margin:10px 0}
.scroll-buttons{position:fixed;bottom:20px;right:20px;display:flex;flex-direction:column;gap:6px;z-index:1000}
.scroll-btn{width:32px;height:32px;border-radius:50%;background:#6c757d;color:white;border:none;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;box-shadow:0 1px 4px rgba(0,0,0,0.15);transition:all 0.2s;position:relative}
.scroll-btn:hover{background:#5a6268;transform:scale(1.05)}
.scroll-btn:hover::after{content:attr(title);position:absolute;background:#333;color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;white-space:nowrap;right:calc(100% + 10px);top:50%;transform:translateY(-50%);z-index:1001;pointer-events:none}
.scroll-btn:hover::before{content:'';position:absolute;right:-5px;top:50%;transform:translateY(-50%);border:5px solid transparent;border-left-color:#333;pointer-events:none}
.save-btn{width:32px;height:32px;border-radius:50%;background:#0052cc;color:white;border:none;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:16px;box-shadow:0 1px 4px rgba(0,0,0,0.15);transition:all 0.2s;position:relative}
.save-btn:hover{background:#0041a8;transform:scale(1.05)}
.save-btn:hover::after{content:attr(title);position:absolute;background:#333;color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;white-space:nowrap;right:calc(100% + 10px);top:50%;transform:translateY(-50%);z-index:1001;pointer-events:none}
.save-btn:hover::before{content:'';position:absolute;right:-5px;top:50%;transform:translateY(-50%);border:5px solid transparent;border-left-color:#333;pointer-events:none}
.save-btn.save-source{background:#28a745}
.save-btn.save-source:hover{background:#218838}
.load-btn-row{display:flex;justify-content:center;margin-top:10px}
.structure-info{padding:10px;background:#e8f4fd;border-radius:4px;margin-top:10px;font-size:12px;max-height:200px;overflow-y:auto}
.structure-info h4{margin:0 0 5px 0;color:#0052cc}
.structure-info ul{margin:0;padding-left:20px}
.structure-info li{margin:2px 0}
.toggle-list-btn{background:none;border:none;color:#0052cc;cursor:pointer;font-size:11px;padding:2px 5px;margin-left:5px;text-decoration:underline}
.toggle-list-btn:hover{color:#0041a8}
.key-count{font-weight:normal;font-size:11px;color:#6c757d;margin-left:5px}
.collapsible-section{margin-bottom:10px}
.collapsible-header{display:flex;justify-content:space-between;align-items:center;cursor:pointer;padding:5px;background:#e9ecef;border-radius:4px}
.collapsible-header:hover{background:#dee2e6}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height 0.3s ease;background:#fff;border-radius:0 0 4px 4px}
.collapsible-content.expanded{max-height:200px;overflow-y:auto !important;padding:8px}
.collapsible-icon{transition:transform 0.3s}
.collapsible-icon.expanded{transform:rotate(180deg)}
.collapsible-content ul{margin:0;padding-left:20px;max-height:180px;overflow-y:auto}
.collapsible-content li{margin:3px 0;padding:3px;font-family:monospace;font-size:11px;word-break:break-all}
.collapsible-content code{background:#f1f1f1;padding:2px 4px;border-radius:3px;color:#333}
.reset-box.compact{padding:8px !important;min-height:60px !important;border-width:1px !important}

/* Error highlighting styles */
.source-text.missing, .source-input.missing, .translation-input.missing {
  border-color: #dc3545 !important;
  background-color: #fff5f5 !important;
  color: #dc3545 !important;
}

.source-text.extra, .source-input.extra, .translation-input.extra {
  border-color: #6c757d !important;
  background-color: #f8f9fa !important;
  color: #6c757d !important;
}

.source-text.type-mismatch, .source-input.type-mismatch, .translation-input.type-mismatch {
  border-color: #ffc107 !important;
  background-color: #fff9e6 !important;
  color: #856404 !important;
}

.error-indicator {
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 3px;
  margin-top: 4px;
  display: inline-block;
  font-weight: bold;
}

.error-indicator.missing {
  background-color: #dc3545;
  color: white;
}

.error-indicator.extra {
  background-color: #6c757d;
  color: white;
}

.error-indicator.type-mismatch {
  background-color: #ffc107;
  color: #856404;
}

/* Tooltip styles */
.tooltip {
  position: relative;
  display: inline-block;
}

.tooltip .tooltiptext {
  visibility: hidden;
  width: 300px;
  background-color: #333;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 8px;
  position: absolute;
  z-index: 1001;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  white-space: pre-line;
  pointer-events: none;
}

.tooltip .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #333 transparent transparent transparent;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
}

/* Prevent tooltip overflow on very small screens */
@media (max-width: 768px) {
  .scroll-buttons {
    bottom: 10px;
    right: 10px;
  }
  
  .scroll-btn:hover::after,
  .save-btn:hover::after {
    right: calc(100% + 5px);
    font-size: 11px;
    padding: 3px 6px;
  }
  
  .scroll-btn:hover::before,
  .save-btn:hover::before {
    right: -4px;
  }
  
  .tooltip .tooltiptext {
    width: 250px;
    font-size: 11px;
  }
}
</style>
</head>
<body>
<div class="container">
<div class="upload-row">
<div class="reset-box" id="resetBox" onclick="resetAll()">
<h3>Reset</h3>
<div>Start over</div>
</div>
<div class="upload-box" id="sourceBox" onclick="handleSourceBoxClick()">
<h3>Source JSON</h3>
<div>Click or drop JSON file</div>
<input type="file" id="sourceFile" accept=".json,application/json">
<div class="file-info" id="sourceInfo"></div>
</div>
<div class="upload-box" id="targetBox" onclick="handleTargetBoxClick()">
<h3>Target JSON</h3>
<div>Click or drop JSON file</div>
<input type="file" id="targetFile" accept=".json,application/json">
<div class="file-info" id="targetInfo"></div>
</div>
</div>
<div id="error" class="error"></div>
<div id="warning" class="warning"></div>
<div class="status" id="status">Load source and target JSON files to begin</div>
<div class="editor" id="editor">
<div class="editor-header">
<div>Source Text</div>
<div>Translation</div>
</div>
<div class="translation-list" id="translationList"></div>
</div>
<div class="scroll-buttons" id="scrollButtons" style="display:none">
<button class="save-btn save-source" id="floatSaveSourceBtn" onclick="saveSource()" title="Save Source JSON" style="display:none">ðŸ’¾</button>
<button class="save-btn" id="floatSaveTargetBtn" onclick="saveTarget()" title="Save Target JSON">ðŸ’¾</button>
<button class="scroll-btn" onclick="scrollToTop()" title="Scroll to top">â†‘</button>
<button class="scroll-btn" onclick="scrollToBottom()" title="Scroll to bottom">â†“</button>
</div>
</div>
<script>
let sourceData=null,targetData=null,items=[],keyMap={}
let sourceFileName='source.json',targetFileName='translation.json'
let sourceChanged=false
let originalSourceValues={}
let lastSavedSourceValues={}
let originalTargetValues={}
let itemLocks={}
let filteredTargetData=null
let missingKeys=[], extraKeys=[], typeMismatches=[]
let targetHasUnsavedChanges = false

// Track which items have issues
let itemIssues={} // path -> { type: 'missing'|'extra'|'type-mismatch', message: string }

// Get references to upload boxes
const sourceBox=document.getElementById('sourceBox')
const targetBox=document.getElementById('targetBox')
const resetBox=document.getElementById('resetBox')
const sourceFileInput=document.getElementById('sourceFile')
const targetFileInput=document.getElementById('targetFile')

// Setup drag and drop events
setupDragAndDrop(sourceBox,sourceFileInput)
setupDragAndDrop(targetBox,targetFileInput)

// Add event listeners for file inputs
document.getElementById('sourceFile').addEventListener('change',e=>handleFile(e,'source'))
document.getElementById('targetFile').addEventListener('change',e=>handleFile(e,'target'))

// Click handlers for upload boxes
function handleSourceBoxClick() {
  // If editor is loaded, we cannot change the source
  if(document.getElementById('editor').style.display==='block'){
    showError('Source file cannot be changed while editing. Please reset first.')
    return
  }
  
  // Check for unsaved changes
  if(sourceData && (sourceChanged || targetHasUnsavedChanges)) {
    let message = 'You have unsaved changes:\n\n'
    let hasChanges = false
    
    if(sourceChanged) {
      message += '- Source has been modified\n'
      hasChanges = true
    }
    
    if(targetHasUnsavedChanges) {
      message += '- Target translations have been modified\n'
      hasChanges = true
    }
    
    message += '\nLoading a new file will discard these changes. Do you want to continue?'
    
    if(hasChanges && !confirm(message)) {
      return
    }
  }
  
  // Trigger file input
  sourceFileInput.click()
}

function handleTargetBoxClick() {
  // Check for unsaved changes
  if(targetData && (targetHasUnsavedChanges || sourceChanged)) {
    let message = 'You have unsaved changes:\n\n'
    let hasChanges = false
    
    if(sourceChanged) {
      message += '- Source has been modified\n'
      hasChanges = true
    }
    
    if(targetHasUnsavedChanges) {
      message += '- Target translations have been modified\n'
      hasChanges = true
    }
    
    message += '\nLoading a new file will discard these changes. Do you want to continue?'
    
    if(hasChanges && !confirm(message)) {
      return
    }
  }
  
  // Trigger file input
  targetFileInput.click()
}

function setupDragAndDrop(box,fileInput){
  box.addEventListener('dragover',e=>{
    e.preventDefault()
    if(fileInput.disabled) return
    box.classList.add('active')
    if(box===sourceBox){
      targetBox.classList.add('inactive')
    }else{
      sourceBox.classList.add('inactive')
    }
  })
  
  box.addEventListener('dragleave',e=>{
    e.preventDefault()
    if(!box.contains(e.relatedTarget)){
      box.classList.remove('active')
      sourceBox.classList.remove('inactive')
      targetBox.classList.remove('inactive')
    }
  })
  
  box.addEventListener('drop',e=>{
    e.preventDefault()
    box.classList.remove('active')
    sourceBox.classList.remove('inactive')
    targetBox.classList.remove('inactive')
    
    if(fileInput.disabled) return
    
    // Check for unsaved changes before dropping a new file
    if(e.dataTransfer.files.length){
      if(box === sourceBox && sourceData && (sourceChanged || targetHasUnsavedChanges)) {
        let message = 'You have unsaved changes:\n\n'
        let hasChanges = false
        
        if(sourceChanged) {
          message += '- Source has been modified\n'
          hasChanges = true
        }
        
        if(targetHasUnsavedChanges) {
          message += '- Target translations have been modified\n'
          hasChanges = true
        }
        
        message += '\nLoading a new file will discard these changes. Do you want to continue?'
        
        if(hasChanges && !confirm(message)) {
          return
        }
      }
      
      if(box === targetBox && targetData && (targetHasUnsavedChanges || sourceChanged)) {
        let message = 'You have unsaved changes:\n\n'
        let hasChanges = false
        
        if(sourceChanged) {
          message += '- Source has been modified\n'
          hasChanges = true
        }
        
        if(targetHasUnsavedChanges) {
          message += '- Target translations have been modified\n'
          hasChanges = true
        }
        
        message += '\nLoading a new file will discard these changes. Do you want to continue?'
        
        if(hasChanges && !confirm(message)) {
          return
        }
      }
      
      fileInput.files=e.dataTransfer.files
      const event=new Event('change',{bubbles:true})
      fileInput.dispatchEvent(event)
    }
  })
}

function handleFile(e,type){
  let file=e.target.files[0]
  if(!file)return
  
  let reader=new FileReader()
  reader.onload=function(event){
    try{
      let text=event.target.result
      let data=JSON.parse(text)
      if(type==='source'){
        sourceData=data
        keyMap=createKeyMap(sourceData)
        sourceFileName=file.name
        document.getElementById('sourceInfo').textContent=`${file.name} (${Object.keys(keyMap).length} items)`
        
        // After loading source, update upload boxes
        updateUploadBoxes()
      }else{
        targetData=data
        targetFileName=file.name
        document.getElementById('targetInfo').textContent=file.name
        
        // After loading target, update upload boxes
        updateUploadBoxes()
      }
      document.getElementById('error').style.display='none'
      document.getElementById('warning').style.display='none'
      updateUIState()
      
      // Automatically load editor when both files are loaded
      if(sourceData && targetData) {
        loadFiles()
      }
    }catch(err){
      showError(`Invalid JSON in ${type}: ${err.message}`)
    }
  }
  reader.readAsText(file,'UTF-8')
}

function updateUploadBoxes(){
  // If editor is open, make ALL boxes super compact
  if(document.getElementById('editor').style.display==='block'){
    sourceBox.classList.add('compact');
    targetBox.classList.add('compact');
    resetBox.classList.add('compact');
    return;
  }
  
  // Reset all classes first
  sourceBox.classList.remove('active','inactive','compact');
  targetBox.classList.remove('active','inactive','compact');
  resetBox.classList.remove('compact');
  
  if(sourceData&&targetData){
    // Both files loaded, make them compact
    sourceBox.classList.add('compact');
    targetBox.classList.add('compact');
  }else if(sourceData){
    // Only source loaded
    sourceBox.classList.add('compact');
    targetBox.classList.add('active');
  }else if(targetData){
    // Only target loaded
    targetBox.classList.add('compact');
  }
}

function updateUIState(){
  if(sourceData&&targetData){
    // No longer show the load button - editor loads automatically
    resetBox.style.display='flex' // Show reset box when both files loaded
    updateStatus()
  }else if(sourceData){
    resetBox.style.display='none' // Hide reset box if not both files
    updateStatus()
  }else if(targetData){
    resetBox.style.display='none' // Hide reset box if not both files
    updateStatus()
  }else{
    resetBox.style.display='none' // Hide reset box if no files
    updateStatus()
  }
}

function createKeyMap(obj,path=''){
  let map={}
  for(let k in obj){
    if(!obj.hasOwnProperty(k))continue
    let cur=path?path+'.'+k:k
    let val=obj[k]
    if(val!==null&&typeof val==='object'){
      if(Array.isArray(val)){
        val.forEach((item,i)=>{
          let arrPath=cur+'['+i+']'
          if(typeof item==='string'){
            map[arrPath]='string'
          }else if(item!==null&&typeof item==='object'){
            Object.assign(map,createKeyMap(item,arrPath))
          }
        })
      }else{
        Object.assign(map,createKeyMap(val,cur))
      }
    }else{
      map[cur]=typeof val
    }
  }
  return map
}

function updateStatus(){
  let status=document.getElementById('status')
  if(!sourceData&&!targetData){
    status.textContent='Load source and target JSON files to begin'
    status.style.display='block'
  }else if(sourceData&&!targetData){
    status.textContent='Source loaded. Now load target JSON file.'
    status.style.display='block'
  }else if(!sourceData&&targetData){
    status.textContent='Target loaded. Now load source JSON file.'
    status.style.display='block'
  }else{
    status.style.display='none'
  }
}

function loadFiles(){
  if(!sourceData||!targetData){
    showError('Please load both files first')
    return
  }
  
  let targetMap=createKeyMap(targetData)
  missingKeys=[]
  extraKeys=[]
  typeMismatches=[]
  itemIssues={}
  
  // Check for mismatches
  for(let k in keyMap){
    if(!targetMap.hasOwnProperty(k)){
      missingKeys.push(k)
      itemIssues[k]={type:'missing',message:'Missing in target'}
    }else if(keyMap[k]!==targetMap[k]){
      typeMismatches.push(`"${k}": source is ${keyMap[k]}, target is ${targetMap[k]}`)
      itemIssues[k]={type:'type-mismatch',message:`Type mismatch: source is ${keyMap[k]}, target is ${targetMap[k]}`}
    }
  }
  
  // Check for extra keys in target
  for(let k in targetMap){
    if(!keyMap.hasOwnProperty(k)){
      extraKeys.push(k)
    }
  }
  
  // Build filtered target data that matches source structure
  filteredTargetData=JSON.parse(JSON.stringify(sourceData)) // Deep clone source structure
  
  // Populate filtered target with values from original target where keys match
  items=extractItems(sourceData)
  items.forEach(item=>{
    itemLocks[item.path]=true
    let sourceVal=getValue(sourceData,item.path)
    originalSourceValues[item.path]=sourceVal
    lastSavedSourceValues[item.path]=sourceVal
    
    // Get value from target if it exists and type matches
    let targetVal=getValue(targetData,item.path)
    if(targetVal!==undefined && typeof targetVal===keyMap[item.path]){
      setValue(filteredTargetData,item.path,targetVal)
      originalTargetValues[item.path]=targetVal
    }else{
      // For missing keys: Keep empty in target so user can add translation
      // For type mismatches: Use target value (even if type is wrong) but mark as error
      if(!targetMap.hasOwnProperty(item.path)){
        // Missing key - keep empty in target
        setValue(filteredTargetData,item.path,'')
        originalTargetValues[item.path]=''
      }else{
        // Type mismatch - use target value but mark as error
        setValue(filteredTargetData,item.path,targetVal)
        originalTargetValues[item.path]=targetVal
      }
    }
  })
  
  // For extra keys in target, create special items
  extraKeys.forEach(path=>{
    let targetVal=getValue(targetData,path)
    items.push({
      path: path,
      key: path,
      value: targetVal,
      type: typeof targetVal,
      isArray: false,
      isExtra: true // Mark as extra key
    })
    itemIssues[path]={type:'extra',message:'Extra in target'}
    originalTargetValues[path]=targetVal
  })
  
  // Replace targetData with filtered version
  targetData=filteredTargetData
  
  // Show warnings if there are mismatches
  updateWarningPanel()
  
  sourceChanged=false
  targetHasUnsavedChanges = false
  renderEditor()
}

function updateWarningPanel(){
  if(missingKeys.length===0 && extraKeys.length===0 && typeMismatches.length===0){
    document.getElementById('warning').style.display='none';
    return;
  }
  
  let warningMsg='';
  
  if(missingKeys.length>0){
    warningMsg+=`<div class="collapsible-section">
      <div class="collapsible-header" onclick="toggleCollapsible('missing')">
        <h4>Missing in target <span class="key-count">(${missingKeys.length})</span></h4>
        <span class="collapsible-icon" id="missingIcon">â–¼</span>
      </div>
      <div class="collapsible-content" id="missingContent">
        <ul>${missingKeys.map(k=>`<li><code>${k}</code></li>`).join('')}</ul>
      </div>
    </div>`;
  }
  
  if(extraKeys.length>0){
    warningMsg+=`<div class="collapsible-section">
      <div class="collapsible-header" onclick="toggleCollapsible('extra')">
        <h4>Extra in target <span class="key-count">(${extraKeys.length})</span></h4>
        <span class="collapsible-icon" id="extraIcon">â–¼</span>
      </div>
      <div class="collapsible-content" id="extraContent">
        <ul>${extraKeys.map(k=>`<li><code>${k}</code></li>`).join('')}</ul>
      </div>
    </div>`;
  }
  
  if(typeMismatches.length>0){
    warningMsg+=`<div class="collapsible-section">
      <div class="collapsible-header" onclick="toggleCollapsible('type')">
        <h4>Type mismatches <span class="key-count">(${typeMismatches.length})</span></h4>
        <span class="collapsible-icon" id="typeIcon">â–¼</span>
      </div>
      <div class="collapsible-content" id="typeContent">
        <ul>${typeMismatches.map(k=>`<li><code>${k}</code></li>`).join('')}</ul>
      </div>
    </div>`;
  }
  
  document.getElementById('warning').innerHTML=warningMsg;
  document.getElementById('warning').style.display='block';
}

function toggleCollapsible(type){
  const content=document.getElementById(type+'Content')
  const icon=document.getElementById(type+'Icon')
  
  if(content.classList.contains('expanded')){
    content.classList.remove('expanded')
    icon.classList.remove('expanded')
  }else{
    content.classList.add('expanded')
    icon.classList.add('expanded')
  }
}

function extractItems(obj,path=''){
  let result=[]
  for(let k in obj){
    if(!obj.hasOwnProperty(k))continue
    let cur=path?path+'.'+k:k
    let val=obj[k]
    if(val!==null&&typeof val==='object'){
      if(Array.isArray(val)){
        val.forEach((item,i)=>{
          let arrPath=cur+'['+i+']'
          if(typeof item==='string'){
            result.push({path:arrPath,key:cur,value:item,type:'string',isArray:true,index:i})
          }else if(item!==null&&typeof item==='object'){
            result=result.concat(extractItems(item,arrPath))
          }
        })
      }else{
        result=result.concat(extractItems(val,cur))
      }
    }else{
      result.push({path:cur,key:cur,value:val,type:typeof val,isArray:false})
    }
  }
  return result
}

function getValue(obj,path){
  let parts=path.split(/[\.\[\]]+/).filter(p=>p!=='')
  let cur=obj
  for(let p of parts){
    if(cur===undefined||cur===null)return undefined
    cur=cur[p]
  }
  return cur
}

function detectTextDirection(text) {
  if (!text || typeof text !== 'string') return 'ltr';
  
  // Remove common punctuation and symbols
  const cleanText = text.replace(/[^\p{L}\p{N}]/gu, '');
  if (!cleanText) return 'ltr';
  
  // Check for RTL characters
  const rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u0700-\u074F\u0780-\u07BF\u07C0-\u07FF]/;
  
  return rtlRegex.test(cleanText) ? 'rtl' : 'ltr';
}

function renderEditor(){
  let list=document.getElementById('translationList')
  let html=''
  
  let hasSourceChanges=false
  
  // Sort items: source items first, then extra target items
  items.sort((a, b) => {
    if (a.isExtra && !b.isExtra) return 1;
    if (!a.isExtra && b.isExtra) return -1;
    return 0;
  });
  
  items.forEach((item,i)=>{
    let targetVal=getValue(targetData,item.path)
    let isLocked=itemLocks[item.path] || false
    let currentSourceValue=getValue(sourceData,item.path)
    let lastSavedValue=lastSavedSourceValues[item.path]
    let originalSourceValue=originalSourceValues[item.path]
    let originalTargetValue=originalTargetValues[item.path]
    let issue=itemIssues[item.path]
    
    // Check if value has changed from last saved (for Save button)
    let isSourceChangedForSave=lastSavedValue!==undefined && 
                       currentSourceValue!==lastSavedValue
    
    // Check if value has changed from original (for highlighting)
    let isSourceChangedForHighlight=originalSourceValue!==undefined && 
                       currentSourceValue!==originalSourceValue
    
    if(isSourceChangedForSave) hasSourceChanges=true
    
    let isTargetChanged=originalTargetValue!==undefined && 
                       targetVal!==originalTargetValue
    
    // Detect text direction
    let sourceDir = detectTextDirection(currentSourceValue);
    let targetDir = detectTextDirection(targetVal);
    
    if(item.type==='string'){
      let sourceContent,sourceClasses,sourceError=''
      let targetClasses,sourceExtraClasses='',targetExtraClasses=''
      
      // Apply error classes - but only if target is empty
      if(issue){
        if(issue.type==='missing'){
          // Only show missing error if target is still empty
          if(!targetVal || targetVal.trim() === ''){
            targetExtraClasses+=' missing'
            sourceError=`<div class="error-indicator missing">Missing in target</div>`
          }
        }else if(issue.type==='type-mismatch'){
          sourceExtraClasses+=' type-mismatch'
          targetExtraClasses+=' type-mismatch'
          sourceError=`<div class="error-indicator type-mismatch">Type mismatch</div>`
        }else if(issue.type==='extra'){
          sourceExtraClasses+=' extra'
          sourceError=`<div class="error-indicator extra">Extra in target</div>`
        }
      }
      
      if(item.isExtra){
        // This is an extra key in target (not in source)
        sourceClasses='source-text extra'
        sourceContent=`<div class="${sourceClasses}" dir="ltr"><em>Key not in source</em><div class="key-path">${item.path}</div></div>`
        
        targetClasses='translation-input'
        if(isTargetChanged) targetClasses+=' changed'
        targetClasses+=targetExtraClasses
        
        html+=`<div class="translation-item">
          <div class="source-area">
            ${sourceContent}
            ${sourceError}
          </div>
          <textarea class="${targetClasses}" data-path="${escapeHtml(item.path)}" placeholder="Extra key in target..." oninput="updateTranslation(this,'${item.path}')" dir="${targetDir}">${targetVal!==undefined?escapeHtml(targetVal):''}</textarea>
        </div>`
      }else{
        // Normal source key
        if(isLocked){
          sourceClasses='source-text'
          if(isSourceChangedForHighlight) sourceClasses+=' changed'
          sourceClasses+=sourceExtraClasses
          sourceContent=`<div class="${sourceClasses}" dir="${sourceDir}">${escapeHtml(currentSourceValue)}${item.isArray?`<span class="array-indicator">[${item.index}]</span>`:''}<div class="key-path">${item.path}</div></div>`
        }else{
          sourceClasses='source-input'
          if(isSourceChangedForHighlight) sourceClasses+=' changed'
          sourceClasses+=sourceExtraClasses
          sourceContent=`<textarea class="${sourceClasses}" data-path="${escapeHtml(item.path)}" oninput="updateSource(this,'${item.path}')" dir="${sourceDir}">${escapeHtml(currentSourceValue)}</textarea><div class="key-path">${item.path}</div>`
        }
        
        targetClasses='translation-input'
        if(isTargetChanged) targetClasses+=' changed'
        targetClasses+=targetExtraClasses
        
        // For missing keys, targetVal will be empty string
        let displayTargetVal = targetVal!==undefined ? escapeHtml(targetVal) : '';
        let placeholderText = 'Translation...';
        if(issue && issue.type==='missing' && (!targetVal || targetVal.trim() === '')){
          placeholderText = 'Missing in target';
        }
        
        html+=`<div class="translation-item">
          <div class="source-area">
            ${sourceContent}
            ${sourceError}
            <button class="lock-btn" title="${isLocked?'Unlock source':'Lock source'}" onclick="toggleSourceLock('${item.path}')">${isLocked?'ðŸ”’':'ðŸ”“'}</button>
          </div>
          <textarea class="${targetClasses}" data-path="${escapeHtml(item.path)}" placeholder="${placeholderText}" oninput="updateTranslation(this,'${item.path}')" dir="${targetDir}">${displayTargetVal}</textarea>
        </div>`
      }
    }else{
      // Non-string type
      let sourceExtraClasses=''
      if(issue&&issue.type==='type-mismatch'){
        sourceExtraClasses+=' type-mismatch'
      }
      
      html+=`<div class="translation-item">
        <div class="source-text ${sourceExtraClasses}" dir="ltr">${currentSourceValue}<div class="key-path">${item.path} (${item.type})</div></div>
        <div style="padding:6px;color:#666;font-style:italic;font-size:13px">Not editable - ${item.type}</div>
      </div>`
    }
  })
  
  list.innerHTML=html
  document.getElementById('editor').style.display='block'
  document.getElementById('status').style.display='none'
  document.getElementById('scrollButtons').style.display='flex'
  
  // Make upload boxes super compact when editor is open
  updateUploadBoxes()
  
  // Disable source file input and visually indicate it's disabled
  sourceFileInput.disabled=true
  sourceBox.classList.add('disabled')
  
  autoExpandTextareas()
  
  // Update save source button visibility
  document.getElementById('floatSaveSourceBtn').style.display=hasSourceChanges?'flex':'none'
  sourceChanged=hasSourceChanges
}

function updateTranslation(textarea,path){
  let value=textarea.value
  setValue(targetData,path,value)
  
  // Update changed state by comparing with original
  let originalValue=originalTargetValues[path]
  let isChanged=originalValue!==undefined && value!==originalValue
  
  // Update textarea class
  textarea.classList.remove('changed', 'missing')
  if(isChanged){
    textarea.classList.add('changed')
  } else if(value === '' || value.trim() === '') {
    // If value is empty and this was a missing key, keep it red
    let issue = itemIssues[path]
    if(issue && issue.type === 'missing') {
      textarea.classList.add('missing')
    }
  }
  
  // Update text direction based on content
  let dir = detectTextDirection(value);
  textarea.setAttribute('dir', dir);
  
  // Track that there are unsaved changes
  if(isChanged) {
    targetHasUnsavedChanges = true
  }
  
  autoExpand(textarea)
}

function updateSource(textarea,path){
  let value=textarea.value
  setValue(sourceData,path,value)
  
  // Get current values for comparison
  let currentValue=getValue(sourceData,path)
  let lastSavedValue=lastSavedSourceValues[path]
  let originalValue=originalSourceValues[path]
  
  // Update changed state for highlighting (compare with original)
  let isChangedForHighlight=originalValue!==undefined && currentValue!==originalValue
  
  // Update changed state for save button (compare with last saved)
  let isChangedForSave=lastSavedValue!==undefined && currentValue!==lastSavedValue
  
  // Update textarea class for highlighting
  textarea.classList.remove('changed')
  if(isChangedForHighlight){
    textarea.classList.add('changed')
  }
  
  // Update text direction based on content
  let dir = detectTextDirection(value);
  textarea.setAttribute('dir', dir);
  
  // Update source changed state
  sourceChanged = isChangedForSave
  
  // Update save source button visibility
  document.getElementById('floatSaveSourceBtn').style.display=sourceChanged?'flex':'none'
  autoExpand(textarea)
}

function setValue(obj,path,value){
  let parts=path.split(/[\.\[\]]+/).filter(p=>p!=='')
  let cur=obj
  for(let i=0;i<parts.length-1;i++){
    let p=parts[i]
    if(cur[p]===undefined){
      cur[p]=/^\d+$/.test(parts[i+1])?[]:{}
    }
    cur=cur[p]
  }
  if(parts.length>0){
    cur[parts[parts.length-1]]=value
  }
}

function toggleSourceLock(path){
  itemLocks[path]=!itemLocks[path]
  renderEditor()
}

function autoExpandTextareas(){
  document.querySelectorAll('.source-input, .translation-input').forEach(t=>autoExpand(t))
}

function autoExpand(t){
  t.style.height='auto'
  t.style.height=(t.scrollHeight)+'px'
}

function scrollToTop(){
  const editor=document.getElementById('editor')
  editor.scrollIntoView({behavior:'smooth'})
}

function scrollToBottom(){
  const editor=document.getElementById('editor')
  const translationList=document.getElementById('translationList')
  const lastItem=translationList.lastElementChild
  
  if(lastItem){
    lastItem.scrollIntoView({behavior:'smooth',block:'end'})
  }else{
    editor.scrollIntoView({behavior:'smooth',block:'end'})
  }
}

function promptForFilename(defaultName, title) {
  const newName = prompt(`${title}\n\nEnter filename:`, defaultName);
  if (newName === null) {
    return null; // User cancelled
  }
  // Ensure the filename ends with .json
  if (newName.trim() && !newName.toLowerCase().endsWith('.json')) {
    return newName.trim() + '.json';
  }
  return newName.trim() || defaultName;
}

function saveSource(){
  if(!sourceData||!sourceChanged){
    showError('No changes to save')
    return
  }
  
  // Ask for filename
  const newFilename = promptForFilename(sourceFileName, 'Save Source JSON');
  if (newFilename === null) {
    return; // User cancelled
  }
  
  // Update the filename
  sourceFileName = newFilename;
  
  let jsonStr=JSON.stringify(sourceData,null,2)
  let blob=new Blob(['\uFEFF'+jsonStr],{type:'application/json;charset=utf-8'})
  let a=document.createElement('a')
  a.href=URL.createObjectURL(blob)
  a.download=sourceFileName
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(a.href)
  
  // Lock all source fields
  items.forEach(item=>{
    if(!item.isExtra){
      itemLocks[item.path]=true
    }
  })
  
  // Update last saved values (for Save button logic)
  items.forEach(item=>{
    if(!item.isExtra){
      lastSavedSourceValues[item.path]=getValue(sourceData,item.path)
    }
  })
  
  sourceChanged=false
  document.getElementById('floatSaveSourceBtn').style.display='none'
  renderEditor()
}

// New function to check for missing translations
function checkForMissingTranslations() {
  const missing = [];
  
  // Check all source string keys to see if they have translations
  for(let k in keyMap){
    if(keyMap[k] === 'string'){
      const targetVal = getValue(targetData, k);
      if (!targetVal || targetVal.trim() === '') {
        missing.push(k);
      }
    }
  }
  
  return missing;
}

// New function to show missing translations error
function showMissingTranslationsError(missingKeys) {
  let message = `Cannot save: ${missingKeys.length} translation(s) are missing or empty:\n\n`;
  
  // Limit to first 10 keys to avoid huge popup
  const displayKeys = missingKeys.slice(0, 10);
  displayKeys.forEach(key => {
    message += `â€¢ ${key}\n`;
  });
  
  if (missingKeys.length > 10) {
    message += `\n... and ${missingKeys.length - 10} more`;
  }
  
  message += `\n\nPlease fill in all missing translations before saving.`;
  
  alert(message);
}

// New function to remove extra keys from target data
function removeExtraKeysFromData(data) {
  // Create a deep copy to avoid modifying the original
  const result = JSON.parse(JSON.stringify(data));
  
  // Function to recursively remove extra keys
  function removeKeys(obj, path = '') {
    for(let k in obj){
      if(!obj.hasOwnProperty(k)) continue;
      
      let curPath = path ? path + '.' + k : k;
      let val = obj[k];
      
      // Check if this is an extra key (not in source keyMap)
      if (!keyMap.hasOwnProperty(curPath)) {
        delete obj[k];
        continue;
      }
      
      // Recursively check nested objects and arrays
      if(val !== null && typeof val === 'object'){
        if(Array.isArray(val)){
          val.forEach((item, i)=>{
            let arrPath = curPath + '[' + i + ']';
            if(item !== null && typeof item === 'object'){
              removeKeys(item, arrPath);
            }
          });
        } else {
          removeKeys(val, curPath);
        }
      }
    }
  }
  
  removeKeys(result);
  return result;
}

function saveTarget(){
  if(!targetData){
    showError('No target data to save')
    return
  }
  
  // Check for missing translations
  const missingTranslations = checkForMissingTranslations();
  if (missingTranslations.length > 0) {
    showMissingTranslationsError(missingTranslations);
    return;
  }
  
  // Check for extra keys and warn user
  if (extraKeys.length > 0) {
    const confirmed = confirm(`Warning: The target file contains ${extraKeys.length} extra key(s) that are not in the source.\n\nThese extra keys will be removed when saving because the target structure will match the source.\n\nClick OK to continue saving, or Cancel to review.`);
    
    if (!confirmed) {
      return;
    }
  }
  
  // Ask for filename
  const newFilename = promptForFilename(targetFileName, 'Save Target JSON');
  if (newFilename === null) {
    return; // User cancelled
  }
  
  // Update the filename
  targetFileName = newFilename;
  
  // Create a copy without extra keys for saving
  const dataToSave = removeExtraKeysFromData(targetData);
  
  let jsonStr=JSON.stringify(dataToSave,null,2)
  let blob=new Blob(['\uFEFF'+jsonStr],{type:'application/json;charset=utf-8'})
  let a=document.createElement('a')
  a.href=URL.createObjectURL(blob)
  a.download=targetFileName
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(a.href)
  
  // Update original values after saving (this removes orange highlights)
  items.forEach(item=>{
    // Only update for keys that are in the source (not extra keys)
    if (!item.isExtra) {
      let targetVal=getValue(targetData,item.path)
      if(targetVal!==undefined){
        originalTargetValues[item.path]=targetVal
      }
    }
  })
  
  // Reset unsaved changes flag
  targetHasUnsavedChanges = false
  
  renderEditor()
}

function resetAll(){
  // Check for unsaved changes
  if(sourceChanged || targetHasUnsavedChanges) {
    let message = 'You have unsaved changes:\n\n'
    let hasChanges = false
    
    if(sourceChanged) {
      message += '- Source has been modified\n'
      hasChanges = true
    }
    
    if(targetHasUnsavedChanges) {
      message += '- Target translations have been modified\n'
      hasChanges = true
    }
    
    message += '\nResetting will discard these changes. Do you want to continue?'
    
    if(hasChanges && !confirm(message)) {
      return
    }
  }
  
  // Reset all data
  sourceData=null
  targetData=null
  filteredTargetData=null
  items=[]
  keyMap={}
  sourceChanged=false
  originalSourceValues={}
  lastSavedSourceValues={}
  originalTargetValues={}
  itemLocks={}
  missingKeys=[]
  extraKeys=[]
  typeMismatches=[]
  itemIssues={}
  targetHasUnsavedChanges = false
  
  // Clear file inputs
  document.getElementById('sourceFile').value=''
  document.getElementById('targetFile').value=''
  
  // Enable source file input
  sourceFileInput.disabled=false
  
  // Clear file info displays
  document.getElementById('sourceInfo').textContent=''
  document.getElementById('targetInfo').textContent=''
  
  // Reset upload boxes to full size
  sourceBox.classList.remove('active','inactive','compact','disabled')
  targetBox.classList.remove('active','inactive','compact','disabled')
  resetBox.classList.remove('compact')
  resetBox.style.display='none' // Hide reset box after reset
  
  // Hide editor and show status
  document.getElementById('editor').style.display='none'
  document.getElementById('status').style.display='block'
  document.getElementById('scrollButtons').style.display='none'
  document.getElementById('error').style.display='none'
  document.getElementById('warning').style.display='none'
  document.getElementById('floatSaveSourceBtn').style.display='none'
  
  // Reset file names
  sourceFileName='source.json'
  targetFileName='translation.json'
  
  updateStatus()
}

function showError(msg){
  let e=document.getElementById('error')
  e.innerHTML=msg
  e.style.display='block'
  document.getElementById('warning').style.display='none'
}

function escapeHtml(t){
  if(t===null||t===undefined)return''
  return t.toString().replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))
}
</script>
</body>
</html>
